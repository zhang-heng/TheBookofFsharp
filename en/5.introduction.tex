\documentclass{book}

\begin{document}
introduction

From the beginning, one of the promises of the .NET Framework has been language interoperability; that is, developers targeting the platform could write code in one language and interact with code written in another language through the Common Language Infrastructure (CLI). Early examples often included a library written in C\# utilizing a library written in Visual Basic, or vice versa. Ideally, this would allow developers to solve different problems using the best language for the job. In practice, things didn’t really work out that way, as developers tended to adopt either C\# or Visual Basic and build entire solutions with that language. This is hardly surprising given that, with few exceptions, the differences between the languages have historically been purely syntactic (and the languages have only grown closer as the platform has matured).

Now, after more than a decade, F\# has emerged as the third major language in the .NET ecosystem. But what does F\# offer that the traditional .NET languages do not, and why should you care?

F\# brings functional programming to .NET development. While both C\# and Visual Basic have some functional aspects, they are, first and foremost, object-oriented languages; they’re concerned primarily with behavior and managing an ever-changing system state. In contrast, F\# is a functional first language, concerned with the application of functions to data. This difference has a dramatic impact not only on how you write code, but also on how you think about it.

As you read through this book, you’ll learn how F\#’s functional nature enforces a variety of constraints that may seem limiting at first, but once you embrace them you’ll likely find that your code is smaller, more correct, and more predictable. Furthermore, you’ll discover how F\#’s many unique constructs simplify common development tasks, thus allowing you to focus on the problem you’re trying to solve rather than the plumbing required by the compiler. These aspects make F\# a perfect complement to C\# and Visual Basic, often paving the way toward realizing .NET’s goal of mixed-language solutions.

Whom Is This Book For?

I have been developing software professionally with C\# on the .NET platform since its earliest public releases back in 2002 and 2003. Thus, I wrote this book for people like me: experienced .NET developers looking to break into functional programming while retaining the safety net of the tools and libraries they’re already using.

While this book is written with an emphasis on .NET development, experienced developers approaching F\# from other backgrounds should still find plenty of value within these pages, as the principles covered aren’t typically platform specific.

How Is This Book Organized?
The Book of F\# is divided into 12 chapters intended to introduce you to each of the major language features. I recommend that you read this book from beginning to end rather than skipping around, as each chapter builds upon the concepts introduced by its predecessors.

Chapter 1: “Meet F\#”  Provides your first glimpse of F\# and describes its place within the .NET ecosystem. In this chapter, you’ll learn what you need to begin coding in F\#, how projects are structured, and some of the nuances that can catch newcomers to the language off guard.

Chapter 2: “F\# Interactive”  Covers the F\# Interactive environment, an indispensable read-evaluate-print loop (REPL) tool that ships with F\#. Here you’ll see how F\# Interactive can help you explore a problem domain and even let you use F\# as a scripting language backed by the full power of the .NET Framework.

Chapter 3: “Fundamentals”  Teaches you about the fundamentals of F\#. Topics covered in this chapter include default immutability, bindings, core data types, type inference, imperative flow control, and generics. Even though many of the concepts addressed in this chapter will be familiar to experienced developers, I encourage you to read through it because F\# often allows you to use them in unexpected ways.

Chapter 4: “Staying Objective”  Provides an in-depth look at F\#’s object-oriented capabilities. In this chapter, you’ll see how to develop rich object models every bit as robust as those developed in more established object-oriented languages like C\# or Visual Basic. Chapter 5: “Let’s Get Functional”  Takes you on a journey into managed functional programming by introducing you to concepts like functions as data, currying, partial application, and delegation. Additionally, you’ll learn about several of the F\# data structures typically associated with functional programming.

Chapter 6: “Going to Collections”  Explores how the various .NET collection types, like arrays and sequences, are represented in F\#. You’ll also be introduced to several new collection types, including F\#’s lists, sets, and maps.

Chapter 7: “Patterns, Patterns, Everywhere”  Introduces one of F\#’s most powerful constructs: the match expression. Here you’ll uncover the various ways you can decompose complex types and branch your code, all within a single expression.

Chapter 8: “Measuring Up”  Shows you how to add another degree of safety to your code by enforcing units of measure (such as inches, feet, meters, and so on) on your numeric types.

Chapter 9: “Can I Quote You on That?”  Explains quoted expressions F\#’s version of LINQ’s expression trees. Here you’ll see how to compose, decompose, and apply quoted expressions.

Chapter 10: “Show Me the Data”  Explores some F\#-specific ways to access data, including query expressions and one of F\#’s most exciting features: type providers.

Chapter 11: “Asynchronous and Parallel Programming”  Provides a brief introduction to asynchronous and parallel programming with F\#. Topics include consuming the Task Parallel Library from F\#, asynchronous workflows, and agent-based programming using MailboxProcessor<'T>.

Chapter 12: “Computation Expressions”  Discusses how to create computation expressions (often called monads in other functional languages) to control how data flows from expression to expression. Additional Resources As an open source language managed by the F\# Software Foundation, F\# is backed by a welcoming community of developers around the world, covering a wide range of disciplines. Although I’ve tried to provide comprehensive explanations and examples throughout the book, if you would like to explore a topic in more detail, you may find these resources helpful.

The Book of F\# companion page (http://nostarch.com/f\_sharp)  This is your source for content updates and the code examples used within this book.

The F\# Software Foundation (http://fsharp.org/)  This should be your first stop. Here you’ll find links to all of the language documentation, including the language reference, the language specification, component design guidelines, and more.

F\# for Fun and Profit (http://fsharpforfunandprofit.com/)  Here you’ll find a plethora of examples covering virtually every aspect of the language.

Try F\# (http://www.tryfsharp.org/)  This browser-based tool lets you experiment with the language and learn it through guided tutorials.

\end{document}
